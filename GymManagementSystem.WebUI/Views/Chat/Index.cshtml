@model GymManagementSystem.WebUI.Models.ChatIndexViewModel

@{
    ViewData["Title"] = "Chat";
}

<div class="chat-page" data-current-user-id="@Model.CurrentUserId">
    <input type="hidden" id="currentUserId" value="@Model.CurrentUserId" />
    @Html.AntiForgeryToken()

    <div class="chat-container">
        <aside class="chat-sidebar">
            <div class="chat-sidebar-header">Conversations</div>
            <ul id="conversationList" class="conversation-list">
                @if (Model.Conversations.Count == 0)
                {
                    <li class="conversation-empty">No assigned conversations yet.</li>
                }
                else
                {
                    foreach (var c in Model.Conversations)
                    {
                        <li class="conversation-item" data-user-id="@c.UserId" data-display-name="@c.DisplayName">
                            <div class="conversation-row">
                                <div class="conversation-name"><span class="status-dot offline" data-status-dot></span><span class="name-text">@c.DisplayName</span></div>
                                <div class="conversation-time">@(c.LastMessageAt?.ToLocalTime().ToString("g") ?? string.Empty)</div>
                            </div>
                            <div class="conversation-status" data-last-seen></div>
                            <div class="conversation-row">
                                <div class="conversation-last">@c.LastMessage</div>
                                <span class="conversation-badge" style="@(c.UnreadCount > 0 ? "" : "display:none")">@c.UnreadCount</span>
                            </div>
                        </li>
                    }
                }
            </ul>
        </aside>

        <section class="chat-main">
            <div class="chat-header">
                <span id="chatHeaderText">Select a conversation</span>
                <button type="button" class="btn btn-sm btn-secondary" data-theme-toggle>Dark Mode</button>
            </div>
            <div id="typingIndicator" class="typing-indicator"></div>
            <div id="messageList" class="message-list"></div>
            <form id="sendForm" class="chat-input">
                <input id="messageInput" type="text" placeholder="Type a message..." autocomplete="off" />
                <input id="fileInput" type="file" accept=".jpg,.jpeg,.png,.pdf" hidden />
                <button id="uploadButton" type="button" title="Upload"><i class="fas fa-paperclip"></i></button>
                <button id="sendButton" type="submit">Send</button>
            </form>
        </section>
    </div>
</div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.7/signalr.min.js"></script>
    <script>
        const currentUserId = document.getElementById("currentUserId").value;
        const conversationList = document.getElementById("conversationList");
        const messageList = document.getElementById("messageList");
        const chatHeader = document.getElementById("chatHeaderText");
        const messageInput = document.getElementById("messageInput");
        const sendForm = document.getElementById("sendForm");
        const fileInput = document.getElementById("fileInput");
        const uploadButton = document.getElementById("uploadButton");
        const typingIndicator = document.getElementById("typingIndicator");
        const antiForgeryToken = document.querySelector("input[name='__RequestVerificationToken']").value;

        let currentPeerId = null;

        const connection = new signalR.HubConnectionBuilder()
            .withUrl("/hubs/chat")
            .withAutomaticReconnect()
            .build();

        function formatTime(dateString) {
            const date = new Date(dateString);
            if (Number.isNaN(date.getTime())) return "";
            return date.toLocaleString();
        }

        function clearMessages() {
            messageList.innerHTML = "";
        }


        function updateUserStatus(userId, isOnline, lastSeen) {
            const item = conversationList.querySelector(`[data-user-id='${userId}']`);
            if (!item) return;
            const dot = item.querySelector("[data-status-dot]");
            const lastSeenEl = item.querySelector("[data-last-seen]");
            if (dot) {
                dot.classList.toggle("online", !!isOnline);
                dot.classList.toggle("offline", !isOnline);
            }
            if (lastSeenEl) {
                if (isOnline) {
                    lastSeenEl.textContent = "";
                } else if (lastSeen) {
                    lastSeenEl.textContent = `Last seen: ${formatTime(lastSeen)}`;
                } else {
                    lastSeenEl.textContent = "Last seen: unknown";
                }
            }
        }

        let typingTimeout = null;
        let typingDebounce = null;
        function showTyping(senderId) {
            if (senderId !== currentPeerId) return;
            const item = conversationList.querySelector(`[data-user-id='${senderId}']`);
            const name = item ? (item.getAttribute("data-display-name") || "User") : "User";
            typingIndicator.textContent = `${name} is typing...`;
            typingIndicator.style.display = "block";
            if (typingTimeout) clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                typingIndicator.textContent = "";
                typingIndicator.style.display = "none";
            }, 2000);
        }

        function renderMessage(msg) {
            const isMe = msg.senderId === currentUserId;
            const wrapper = document.createElement("div");
            wrapper.className = "message " + (isMe ? "me" : "them");
            wrapper.dataset.messageId = msg.id;

            const bubble = document.createElement("div");
            bubble.className = "bubble";

            if (msg.type === 1 && msg.attachmentUrl) {
                const img = document.createElement("img");
                img.src = msg.attachmentUrl;
                img.alt = "attachment";
                img.className = "image-attachment";
                bubble.appendChild(img);
            } else if (msg.type === 2 && msg.attachmentUrl) {
                const link = document.createElement("a");
                link.href = msg.attachmentUrl;
                link.textContent = "Download file";
                link.target = "_blank";
                link.rel = "noopener";
                link.className = "file-attachment";
                bubble.appendChild(link);
            } else {
                bubble.textContent = msg.message;
            }

            if (msg.message && msg.type !== 0) {
                const caption = document.createElement("div");
                caption.className = "attachment-caption";
                caption.textContent = msg.message;
                bubble.appendChild(caption);
            }

            const meta = document.createElement("div");
            meta.className = "meta";
            const senderLabel = isMe ? "You" : (msg.senderName || "Sender");
            let readLabel = "";
            if (isMe) {
                readLabel = msg.isRead ? "Read" : "Unread";
            }            meta.textContent = `${senderLabel} ? ${formatTime(msg.sentAt)}${readLabel ? " ? " + readLabel : ""}`;

            wrapper.appendChild(bubble);
            wrapper.appendChild(meta);
            messageList.appendChild(wrapper);
            messageList.scrollTop = messageList.scrollHeight;
        }

        function markMessagesRead(messageIds) {
            if (!Array.isArray(messageIds)) return;
            messageIds.forEach(id => {
                const node = messageList.querySelector(`[data-message-id='${id}']`);
                if (!node) return;
                node.dataset.isRead = "true";
                const meta = node.querySelector(".meta");
                if (!meta) return;
                const parts = meta.textContent.split(" ? ").filter(p => p && p !== "Read" && p !== "Unread");
                meta.textContent = parts.join(" ? ") + " ? Read";
            });
        }

        function updateConversationPreview(peerId, message, sentAt) {
            const item = conversationList.querySelector(`[data-user-id='${peerId}']`);
            if (!item) return;
            const last = item.querySelector(".conversation-last");
            const time = item.querySelector(".conversation-time");
            if (last) last.textContent = message;
            if (time) time.textContent = formatTime(sentAt);
        }

        function incrementBadge(peerId) {
            const item = conversationList.querySelector(`[data-user-id='${peerId}']`);
            if (!item) return;
            const badge = item.querySelector(".conversation-badge");
            if (!badge) return;
            const current = parseInt(badge.textContent || "0", 10) || 0;
            badge.textContent = current + 1;
            badge.style.display = "inline-flex";
        }

        function clearBadge(peerId) {
            const item = conversationList.querySelector(`[data-user-id='${peerId}']`);
            if (!item) return;
            const badge = item.querySelector(".conversation-badge");
            if (!badge) return;
            badge.textContent = "0";
            badge.style.display = "none";
        }

        async function loadHistory(peerId) {
            if (!peerId) return;
            try {
                const history = await connection.invoke("GetChatHistory", peerId);
                clearMessages();
                history.forEach(renderMessage);
                clearBadge(peerId);

                history
                    .filter(m => m.receiverId === currentUserId && !m.isRead)
                    .forEach(m => connection.invoke("MarkAsRead", m.id));
            } catch (err) {
                console.error(err);
            }
        }

        function setActiveConversation(item) {
            const items = conversationList.querySelectorAll(".conversation-item");
            items.forEach(i => i.classList.remove("active"));
            item.classList.add("active");

            currentPeerId = item.getAttribute("data-user-id");
            const displayName = item.getAttribute("data-display-name") || "Chat";
            chatHeader.textContent = displayName;
            messageInput.disabled = false;
            loadHistory(currentPeerId);
            connection.invoke("OpenConversation", currentPeerId).catch(err => console.error(err));
        }

        conversationList.addEventListener("click", (e) => {
            const item = e.target.closest(".conversation-item");
            if (item) {
                setActiveConversation(item);
            }
        });

        messageInput.addEventListener("input", () => {
            if (!currentPeerId) return;
            if (typingDebounce) clearTimeout(typingDebounce);
            typingDebounce = setTimeout(() => {
                connection.invoke("UserTyping", currentPeerId).catch(err => console.error(err));
            }, 200);
        });


        uploadButton.addEventListener("click", () => {
            fileInput.click();
        });

        fileInput.addEventListener("change", async () => {
            if (!currentPeerId) return;
            if (!fileInput.files || fileInput.files.length === 0) return;
            const file = fileInput.files[0];
            const formData = new FormData();
            formData.append("file", file);

            try {
                const res = await fetch("/Chat/Upload", {
                    method: "POST",
                    headers: { "RequestVerificationToken": antiForgeryToken },
                    body: formData
                });

                if (!res.ok) {
                    console.error("Upload failed");
                    return;
                }

                const data = await res.json();
                const url = data.data?.url || data.url;
                if (!url) {
                    console.error("Upload response missing URL", data);
                    return;
                }

                const ext = (file.name.split('.').pop() || "").toLowerCase();
                const type = (ext === "jpg" || ext === "jpeg" || ext === "png") ? 1 : 2;
                const caption = messageInput.value.trim();

                await connection.invoke("SendAttachment", currentPeerId, caption, type, url);
                messageInput.value = "";
                fileInput.value = "";
            } catch (err) {
                console.error(err);
            }
        });

        sendForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            const text = messageInput.value.trim();
            if (!text || !currentPeerId) return;
            try {
                await connection.invoke("SendMessage", currentPeerId, text);
                messageInput.value = "";
            } catch (err) {
                console.error(err);
            }
        });

        connection.on("ReceiveMessage", (msg) => {
            const peerId = msg.senderId === currentUserId ? msg.receiverId : msg.senderId;
            updateConversationPreview(peerId, msg.message, msg.sentAt);

            if (peerId === currentPeerId) {
                renderMessage(msg);
            } else if (msg.receiverId === currentUserId) {
                incrementBadge(peerId);
            }

            if (msg.receiverId === currentUserId) {
                playNotificationSound();
            }
        });


        const chatNotifyAudio = new Audio('/sounds/chat.mp3');
        chatNotifyAudio.preload = 'auto';
        chatNotifyAudio.volume = 0.6;

        function unlockAudio() {
            chatNotifyAudio.play().then(() => {
                chatNotifyAudio.pause();
                chatNotifyAudio.currentTime = 0;
            }).catch(() => {
                // Ignore autoplay restrictions
            });
            document.removeEventListener('click', unlockAudio);
            document.removeEventListener('keydown', unlockAudio);
        }

        document.addEventListener('click', unlockAudio, { once: true });
        document.addEventListener('keydown', unlockAudio, { once: true });

        function playNotificationSound() {
            chatNotifyAudio.currentTime = 0;
            chatNotifyAudio.play().catch(() => { });
        }

        connection.on("ReceiveUnreadMessages", (messages) => {
            messages.forEach((msg) => {
                const peerId = msg.senderId;
                updateConversationPreview(peerId, msg.message, msg.sentAt);

                if (peerId === currentPeerId) {
                    renderMessage(msg);
                } else {
                    incrementBadge(peerId);
                }
            });
        });

        connection.on("MessageRead", (payload) => {
            if (!payload || !payload.messageIds) return;
            markMessagesRead(payload.messageIds);
        });

        connection.on("UserStatusChanged", (payload) => {
            if (!payload) return;
            updateUserStatus(payload.userId, payload.isOnline, payload.lastSeen);
        });

        connection.on("UserTyping", (payload) => {
            if (!payload) return;
            showTyping(payload.senderId);
        });

        connection.start().then(async () => {
            const items = conversationList.querySelectorAll(".conversation-item");
            for (const item of items) {
                const userId = item.getAttribute("data-user-id");
                if (!userId) continue;
                try {
                    const status = await connection.invoke("GetOnlineStatus", userId);
                    updateUserStatus(status.userId, status.isOnline, status.lastSeen);
                } catch (e) { }
            }

            const firstItem = conversationList.querySelector(".conversation-item");
            if (firstItem) {
                setActiveConversation(firstItem);
            } else {
                messageInput.disabled = true;
            }
        }).catch(err => console.error(err));
    </script>
}

<style>
    .chat-page {
        padding: 1rem 0;
        color: var(--text-color);
        background: var(--chat-bg);
    }

    .chat-container {
        display: grid;
        grid-template-columns: 320px 1fr;
        gap: 1rem;
        min-height: 70vh;
    }

    .chat-sidebar {
        background: var(--chat-surface-alt);
        border-radius: 12px;
        padding: 1rem;
        border: 1px solid var(--chat-border);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .chat-sidebar-header {
        font-weight: 700;
        font-size: 1.1rem;
    }

    .conversation-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .conversation-item {
        background: var(--chat-surface);
        border: 1px solid var(--chat-border);
        border-radius: 10px;
        padding: 0.6rem 0.75rem;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .conversation-item.active {
        border-color: var(--bubble-sender);
        box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.15);
    }

    .conversation-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
    }

    .conversation-name {
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.4rem;
    }

    .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-block;
        background: #aaa;
    }

    .status-dot.online {
        background: #1db954;
    }

    .status-dot.offline {
        background: #9a9a9a;
    }

    .conversation-status {
        font-size: 0.75rem;
        color: var(--text-muted-2);
        margin-top: -0.2rem;
    }

    .conversation-last {
        font-size: 0.9rem;
        color: var(--text-muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 200px;
    }

    .conversation-time {
        font-size: 0.75rem;
        color: var(--text-muted-2);
    }

    .conversation-badge {
        background: var(--badge-bg);
        color: var(--badge-text);
        border-radius: 999px;
        padding: 0 0.45rem;
        font-size: 0.75rem;
        min-width: 1.25rem;
        height: 1.25rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
    }

    .conversation-empty {
        color: var(--text-muted);
        text-align: center;
        padding: 1rem 0;
    }

    .chat-main {
        background: var(--chat-surface);
        border-radius: 12px;
        border: 1px solid var(--chat-border);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .chat-header {
        padding: 0.85rem 1rem;
        font-weight: 700;
        border-bottom: 1px solid var(--chat-border);
        background: var(--chat-surface-alt);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
    }

    .typing-indicator {
        font-size: 0.8rem;
        color: var(--text-muted);
        padding: 0.3rem 1rem;
        display: none;
    }

    .message-list {
        flex: 1;
        padding: 1rem;
        overflow-y: auto;
        background: var(--chat-surface-alt);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .message {
        display: flex;
        flex-direction: column;
        max-width: 70%;
    }

    .message.me {
        align-self: flex-end;
        text-align: right;
    }

    .message.them {
        align-self: flex-start;
        text-align: left;
    }

    .bubble {
        padding: 0.6rem 0.8rem;
        border-radius: 14px;
        background: var(--bubble-receiver);
        color: var(--text-color);
        white-space: pre-wrap;
    }

    .image-attachment {
        max-width: 220px;
        border-radius: 10px;
        display: block;
    }

    .file-attachment {
        color: inherit;
        text-decoration: underline;
        font-weight: 600;
    }

    .attachment-caption {
        margin-top: 0.35rem;
        font-size: 0.85rem;
    }

    .message.me .bubble {
        background: var(--bubble-sender);
        color: var(--badge-text);
    }

    .meta {
        font-size: 0.75rem;
        color: var(--text-muted);
        margin-top: 0.25rem;
    }

    .chat-input {
        display: flex;
        gap: 0.5rem;
        padding: 0.75rem;
        border-top: 1px solid var(--chat-border);
        background: var(--chat-surface);
    }

    #messageInput {
        flex: 1;
        border-radius: 999px;
        border: 1px solid var(--input-border);
        background: var(--input-bg);
        color: var(--text-color);
        padding: 0.5rem 0.9rem;
    }

    #uploadButton {
        border: 1px solid var(--input-border);
        background: var(--chat-surface);
        color: var(--text-color);
        padding: 0.5rem 0.75rem;
        border-radius: 999px;
    }

    #uploadButton:hover {
        background: var(--chat-surface-alt);
    }

    #sendButton {
        border: none;
        background: var(--bubble-sender);
        color: var(--badge-text);
        padding: 0.5rem 1.1rem;
        border-radius: 999px;
    }

    #sendButton:hover {
        background: #2f5c8b;
    }

    @@media (max-width: 900px) {
        .chat-container {
            grid-template-columns: 1fr;
        }

        .conversation-last {
            max-width: 100%;
        }
    }
</style>
